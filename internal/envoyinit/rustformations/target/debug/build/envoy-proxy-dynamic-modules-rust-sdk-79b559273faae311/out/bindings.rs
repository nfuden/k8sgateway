/* automatically generated by rust-bindgen 0.70.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
  pub __mbstate8: [::std::os::raw::c_char; 128usize],
  pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
  ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
  ["Offset of field: __mbstate_t::__mbstate8"]
    [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
  ["Offset of field: __mbstate_t::_mbstateL"]
    [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
  pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
  pub __arg: *mut ::std::os::raw::c_void,
  pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __darwin_pthread_handler_rec"]
    [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
  ["Alignment of __darwin_pthread_handler_rec"]
    [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
  ["Offset of field: __darwin_pthread_handler_rec::__routine"]
    [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
  ["Offset of field: __darwin_pthread_handler_rec::__arg"]
    [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
  ["Offset of field: __darwin_pthread_handler_rec::__next"]
    [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
  ["Alignment of _opaque_pthread_attr_t"]
    [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
  ["Offset of field: _opaque_pthread_attr_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_attr_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
  ["Alignment of _opaque_pthread_cond_t"]
    [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
  ["Offset of field: _opaque_pthread_cond_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_cond_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_condattr_t"]
    [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
  ["Alignment of _opaque_pthread_condattr_t"]
    [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
  ["Offset of field: _opaque_pthread_condattr_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
  ["Alignment of _opaque_pthread_mutex_t"]
    [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
  ["Offset of field: _opaque_pthread_mutex_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_mutexattr_t"]
    [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
  ["Alignment of _opaque_pthread_mutexattr_t"]
    [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
  ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
  ["Alignment of _opaque_pthread_once_t"]
    [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
  ["Offset of field: _opaque_pthread_once_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_once_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_rwlock_t"]
    [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
  ["Alignment of _opaque_pthread_rwlock_t"]
    [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
  ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
  pub __sig: ::std::os::raw::c_long,
  pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_rwlockattr_t"]
    [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
  ["Alignment of _opaque_pthread_rwlockattr_t"]
    [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
  ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
  pub __sig: ::std::os::raw::c_long,
  pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
  pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
  ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
  ["Offset of field: _opaque_pthread_t::__sig"]
    [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
  ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
    [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
  ["Offset of field: _opaque_pthread_t::__opaque"]
    [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[doc = " envoy_dynamic_module_type_abi_version_envoy_ptr represents a null-terminated string that\n contains the ABI version of the dynamic module. This is used to ensure that the dynamic module is\n built against the compatible version of the ABI.\n\n OWNERSHIP: Envoy owns the pointer."]
pub type envoy_dynamic_module_type_abi_version_envoy_ptr = *const ::std::os::raw::c_char;
#[doc = " envoy_dynamic_module_type_http_filter_config_envoy_ptr is a raw pointer to\n the DynamicModuleHttpFilterConfig class in Envoy. This is passed to the module when\n creating a new in-module HTTP filter configuration and used to access the HTTP filter-scoped\n information such as metadata, metrics, etc.\n\n This has 1:1 correspondence with envoy_dynamic_module_type_http_filter_config_module_ptr in\n the module.\n\n OWNERSHIP: Envoy owns the pointer."]
pub type envoy_dynamic_module_type_http_filter_config_envoy_ptr = *const ::std::os::raw::c_void;
#[doc = " envoy_dynamic_module_type_http_filter_config_module_ptr is a pointer to an in-module HTTP\n configuration corresponding to an Envoy HTTP filter configuration. The config is responsible for\n creating a new HTTP filter that corresponds to each HTTP stream.\n\n This has 1:1 correspondence with the DynamicModuleHttpFilterConfig class in Envoy.\n\n OWNERSHIP: The module is responsible for managing the lifetime of the pointer. The pointer can be\n released when envoy_dynamic_module_on_http_filter_config_destroy is called for the same pointer."]
pub type envoy_dynamic_module_type_http_filter_config_module_ptr = *const ::std::os::raw::c_void;
#[doc = " envoy_dynamic_module_type_http_filter_envoy_ptr is a raw pointer to the DynamicModuleHttpFilter\n class in Envoy. This is passed to the module when creating a new HTTP filter for each HTTP stream\n and used to access the HTTP filter-scoped information such as headers, body, trailers, etc.\n\n This has 1:1 correspondence with envoy_dynamic_module_type_http_filter_module_ptr in the module.\n\n OWNERSHIP: Envoy owns the pointer, and can be accessed by the module until the filter is\n destroyed, i.e. envoy_dynamic_module_on_http_filter_destroy is called."]
pub type envoy_dynamic_module_type_http_filter_envoy_ptr = *mut ::std::os::raw::c_void;
#[doc = " envoy_dynamic_module_type_http_filter_module_ptr is a pointer to an in-module HTTP filter\n corresponding to an Envoy HTTP filter. The filter is responsible for processing each HTTP stream.\n\n This has 1:1 correspondence with the DynamicModuleHttpFilter class in Envoy.\n\n OWNERSHIP: The module is responsible for managing the lifetime of the pointer. The pointer can be\n released when envoy_dynamic_module_on_http_filter_destroy is called for the same pointer."]
pub type envoy_dynamic_module_type_http_filter_module_ptr = *const ::std::os::raw::c_void;
#[doc = " envoy_dynamic_module_type_buffer_module_ptr is a pointer to a buffer in the module. A buffer\n represents a contiguous block of memory in bytes.\n\n OWNERSHIP: The module is responsible for managing the lifetime of the pointer. It depends on the\n context where the buffer is used. See for the specific event hook or callback for more details."]
pub type envoy_dynamic_module_type_buffer_module_ptr = *mut ::std::os::raw::c_char;
#[doc = " envoy_dynamic_module_type_buffer_envoy_ptr is a pointer to a buffer in Envoy. A buffer represents\n a contiguous block of memory in bytes.\n\n OWNERSHIP: Envoy owns the pointer. The lifetime depends on the context where the buffer is used.\n See for the specific event hook or callback for more details."]
pub type envoy_dynamic_module_type_buffer_envoy_ptr = *mut ::std::os::raw::c_char;
#[doc = " envoy_dynamic_module_type_envoy_buffer represents a buffer owned by Envoy.\n This is to give the direct access to the buffer in Envoy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct envoy_dynamic_module_type_envoy_buffer {
  pub ptr: envoy_dynamic_module_type_buffer_envoy_ptr,
  pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of envoy_dynamic_module_type_envoy_buffer"]
    [::std::mem::size_of::<envoy_dynamic_module_type_envoy_buffer>() - 16usize];
  ["Alignment of envoy_dynamic_module_type_envoy_buffer"]
    [::std::mem::align_of::<envoy_dynamic_module_type_envoy_buffer>() - 8usize];
  ["Offset of field: envoy_dynamic_module_type_envoy_buffer::ptr"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_envoy_buffer, ptr) - 0usize];
  ["Offset of field: envoy_dynamic_module_type_envoy_buffer::length"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_envoy_buffer, length) - 8usize];
};
#[doc = " envoy_dynamic_module_type_module_http_header represents a key-value pair of an HTTP header owned\n by the module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct envoy_dynamic_module_type_module_http_header {
  pub key_ptr: envoy_dynamic_module_type_buffer_module_ptr,
  pub key_length: usize,
  pub value_ptr: envoy_dynamic_module_type_buffer_module_ptr,
  pub value_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of envoy_dynamic_module_type_module_http_header"]
    [::std::mem::size_of::<envoy_dynamic_module_type_module_http_header>() - 32usize];
  ["Alignment of envoy_dynamic_module_type_module_http_header"]
    [::std::mem::align_of::<envoy_dynamic_module_type_module_http_header>() - 8usize];
  ["Offset of field: envoy_dynamic_module_type_module_http_header::key_ptr"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_module_http_header, key_ptr) - 0usize];
  ["Offset of field: envoy_dynamic_module_type_module_http_header::key_length"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_module_http_header, key_length) - 8usize];
  ["Offset of field: envoy_dynamic_module_type_module_http_header::value_ptr"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_module_http_header, value_ptr) - 16usize];
  ["Offset of field: envoy_dynamic_module_type_module_http_header::value_length"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_module_http_header, value_length) - 24usize];
};
#[doc = " envoy_dynamic_module_type_http_header represents a key-value pair of an HTTP header owned by\n Envoy's HeaderMap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct envoy_dynamic_module_type_http_header {
  pub key_ptr: envoy_dynamic_module_type_buffer_envoy_ptr,
  pub key_length: usize,
  pub value_ptr: envoy_dynamic_module_type_buffer_envoy_ptr,
  pub value_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of envoy_dynamic_module_type_http_header"]
    [::std::mem::size_of::<envoy_dynamic_module_type_http_header>() - 32usize];
  ["Alignment of envoy_dynamic_module_type_http_header"]
    [::std::mem::align_of::<envoy_dynamic_module_type_http_header>() - 8usize];
  ["Offset of field: envoy_dynamic_module_type_http_header::key_ptr"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_http_header, key_ptr) - 0usize];
  ["Offset of field: envoy_dynamic_module_type_http_header::key_length"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_http_header, key_length) - 8usize];
  ["Offset of field: envoy_dynamic_module_type_http_header::value_ptr"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_http_header, value_ptr) - 16usize];
  ["Offset of field: envoy_dynamic_module_type_http_header::value_length"]
    [::std::mem::offset_of!(envoy_dynamic_module_type_http_header, value_length) - 24usize];
};
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_request_headers_status represents the status of the\n filter after processing the HTTP request headers. This corresponds to `FilterHeadersStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_request_headers_status {
  Continue = 0,
  StopIteration = 1,
  ContinueAndDontEndStream = 2,
  StopAllIterationAndBuffer = 3,
  StopAllIterationAndWatermark = 4,
}
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_request_body_status represents the status of the filter\n after processing the HTTP request body. This corresponds to `FilterDataStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_request_body_status {
  Continue = 0,
  StopIterationAndBuffer = 1,
  StopIterationAndWatermark = 2,
  StopIterationNoBuffer = 3,
}
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_request_trailers_status represents the status of the\n filter after processing the HTTP request trailers. This corresponds to `FilterTrailersStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_request_trailers_status {
  Continue = 0,
  StopIteration = 1,
}
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_response_headers_status represents the status of the\n filter after processing the HTTP response headers. This corresponds to `FilterHeadersStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_response_headers_status {
  Continue = 0,
  StopIteration = 1,
  ContinueAndDontEndStream = 2,
  StopAllIterationAndBuffer = 3,
  StopAllIterationAndWatermark = 4,
}
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_response_body_status represents the status of the filter\n after processing the HTTP response body. This corresponds to `FilterDataStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_response_body_status {
  Continue = 0,
  StopIterationAndBuffer = 1,
  StopIterationAndWatermark = 2,
  StopIterationNoBuffer = 3,
}
#[repr(u32)]
#[doc = " envoy_dynamic_module_type_on_http_filter_response_trailers_status represents the status of the\n filter after processing the HTTP response trailers. This corresponds to `FilterTrailersStatus` in\n envoy/http/filter.h."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum envoy_dynamic_module_type_on_http_filter_response_trailers_status {
  Continue = 0,
  StopIteration = 1,
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_program_init is called by the main thread exactly when the module is\n loaded. The function returns the ABI version of the dynamic module. If null is returned, the\n module will be unloaded immediately.\n\n For Envoy, the return value will be used to check the compatibility of the dynamic module.\n\n For dynamic modules, this is useful when they need to perform some process-wide\n initialization or check if the module is compatible with the platform, such as CPU features.\n Note that initialization routines of a dynamic module can also be performed without this function\n through constructor functions in an object file. However, normal constructors cannot be used\n to check compatibility and gracefully fail the initialization because there is no way to\n report an error to Envoy.\n\n @return envoy_dynamic_module_type_abi_version_envoy_ptr is the ABI version of the dynamic\n module. Null means the error and the module will be unloaded immediately."]
  pub fn envoy_dynamic_module_on_program_init() -> envoy_dynamic_module_type_abi_version_envoy_ptr;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_config_new is called by the main thread when the http\n filter config is loaded. The function returns a\n envoy_dynamic_module_type_http_filter_config_module_ptr for given name and config.\n\n @param filter_config_envoy_ptr is the pointer to the DynamicModuleHttpFilterConfig object for the\n corresponding config.\n @param name_ptr is the name of the filter.\n @param name_size is the size of the name.\n @param config_ptr is the configuration for the module.\n @param config_size is the size of the configuration.\n @return envoy_dynamic_module_type_http_filter_config_module_ptr is the pointer to the\n in-module HTTP filter configuration. Returning nullptr indicates a failure to initialize the\n module. When it fails, the filter configuration will be rejected."]
  pub fn envoy_dynamic_module_on_http_filter_config_new(
    filter_config_envoy_ptr: envoy_dynamic_module_type_http_filter_config_envoy_ptr,
    name_ptr: *const ::std::os::raw::c_char,
    name_size: usize,
    config_ptr: *const ::std::os::raw::c_char,
    config_size: usize,
  ) -> envoy_dynamic_module_type_http_filter_config_module_ptr;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_config_destroy is called when the HTTP filter configuration\n is destroyed in Envoy. The module should release any resources associated with the corresponding\n in-module HTTP filter configuration.\n @param filter_config_ptr is a pointer to the in-module HTTP filter configuration whose\n corresponding Envoy HTTP filter configuration is being destroyed."]
  pub fn envoy_dynamic_module_on_http_filter_config_destroy(
    filter_config_ptr: envoy_dynamic_module_type_http_filter_config_module_ptr,
  );
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_new is called when the HTTP filter is created for each HTTP\n stream.\n\n @param filter_config_ptr is the pointer to the in-module HTTP filter configuration.\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @return envoy_dynamic_module_type_http_filter_module_ptr is the pointer to the in-module HTTP\n filter. Returning nullptr indicates a failure to initialize the module. When it fails, the stream\n will be closed."]
  pub fn envoy_dynamic_module_on_http_filter_new(
    filter_config_ptr: envoy_dynamic_module_type_http_filter_config_module_ptr,
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
  ) -> envoy_dynamic_module_type_http_filter_module_ptr;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_request_headers is called when the HTTP request headers are\n received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @param end_of_stream is true if the request headers are the last data.\n @return envoy_dynamic_module_type_on_http_filter_request_headers_status is the status of the\n filter."]
  pub fn envoy_dynamic_module_on_http_filter_request_headers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
    end_of_stream: bool,
  ) -> envoy_dynamic_module_type_on_http_filter_request_headers_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_request_body is called when a new data frame of the HTTP\n request body is received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @param end_of_stream is true if the request body is the last data.\n @return envoy_dynamic_module_type_on_http_filter_request_body_status is the status of the filter."]
  pub fn envoy_dynamic_module_on_http_filter_request_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
    end_of_stream: bool,
  ) -> envoy_dynamic_module_type_on_http_filter_request_body_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_request_trailers is called when the HTTP request trailers are\n received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @return envoy_dynamic_module_type_on_http_filter_request_trailers_status is the status of the\n filter."]
  pub fn envoy_dynamic_module_on_http_filter_request_trailers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
  ) -> envoy_dynamic_module_type_on_http_filter_request_trailers_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_response_headers is called when the HTTP response headers are\n received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @param end_of_stream is true if the response headers are the last data.\n @return envoy_dynamic_module_type_on_http_filter_response_headers_status is the status of the\n filter."]
  pub fn envoy_dynamic_module_on_http_filter_response_headers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
    end_of_stream: bool,
  ) -> envoy_dynamic_module_type_on_http_filter_response_headers_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_response_body is called when a new data frame of the HTTP\n response body is received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @param end_of_stream is true if the response body is the last data.\n @return envoy_dynamic_module_type_on_http_filter_response_body_status is the status of the\n filter."]
  pub fn envoy_dynamic_module_on_http_filter_response_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
    end_of_stream: bool,
  ) -> envoy_dynamic_module_type_on_http_filter_response_body_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_response_trailers is called when the HTTP response trailers\n are received.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param filter_module_ptr is the pointer to the in-module HTTP filter created by\n envoy_dynamic_module_on_http_filter_new.\n @return envoy_dynamic_module_type_on_http_filter_response_trailers_status is the status of the\n filter."]
  pub fn envoy_dynamic_module_on_http_filter_response_trailers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
  ) -> envoy_dynamic_module_type_on_http_filter_response_trailers_status;
}
extern "C" {
  #[doc = " envoy_dynamic_module_on_http_filter_destroy is called when the HTTP filter is destroyed for each\n HTTP stream.\n\n @param filter_module_ptr is the pointer to the in-module HTTP filter."]
  pub fn envoy_dynamic_module_on_http_filter_destroy(
    filter_module_ptr: envoy_dynamic_module_type_http_filter_module_ptr,
  );
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_header is called by the module to get the\n value of the request header with the given key. Since a header can have multiple values, the\n index is used to get the specific value. This returns the number of values for the given key, so\n it can be used to iterate over all values by starting from 0 and incrementing the index until the\n return value.\n\n PRECONDITION: Envoy does not check the validity of the key as well as the result_buffer_ptr\n and result_buffer_length_ptr. The module must ensure that these values are valid, e.g.\n non-null pointers.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param key is the key of the request header.\n @param key_length is the length of the key.\n @param result_buffer_ptr is the pointer to the pointer variable where the pointer to the buffer\n of the value will be stored. If the key does not exist or the index is out of range, this will be\n set to nullptr.\n @param result_buffer_length_ptr is the pointer to the variable where the length of the buffer\n will be stored. If the key does not exist or the index is out of range, this will be set to 0.\n @param index is the index of the header value in the list of values for the given key.\n @return the number of values for the given key, regardless of whether the value is found or not.\n\n Note that a header value is not guaranteed to be a valid UTF-8 string. The module must be careful\n when interpreting the value as a string in the language of the module.\n\n The buffer pointed by the pointer stored in result_buffer_ptr is owned by Envoy, and they are\n guaranteed to be valid until the end of the current event hook unless the setter callback is\n called."]
  pub fn envoy_dynamic_module_callback_http_get_request_header(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result_buffer_ptr: *mut envoy_dynamic_module_type_buffer_envoy_ptr,
    result_buffer_length_ptr: *mut usize,
    index: usize,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_trailer is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_header, but for the request trailers.\n See the comments on envoy_dynamic_module_http_get_request_header_value for more details."]
  pub fn envoy_dynamic_module_callback_http_get_request_trailer(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result_buffer_ptr: *mut envoy_dynamic_module_type_buffer_envoy_ptr,
    result_buffer_length_ptr: *mut usize,
    index: usize,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_header is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_header, but for the response headers.\n See the comments on envoy_dynamic_module_callback_http_get_request_header for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_header(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result_buffer_ptr: *mut envoy_dynamic_module_type_buffer_envoy_ptr,
    result_buffer_length_ptr: *mut usize,
    index: usize,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_trailer is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_header, but for the response trailers.\n See the comments on envoy_dynamic_module_callback_http_get_request_header for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_trailer(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result_buffer_ptr: *mut envoy_dynamic_module_type_buffer_envoy_ptr,
    result_buffer_length_ptr: *mut usize,
    index: usize,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_headers_count is called by the module to get the\n number of request headers. Combined with envoy_dynamic_module_callback_http_get_request_headers,\n this can be used to iterate over all request headers.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @return the number of request headers. Returns zero if the headers are not available."]
  pub fn envoy_dynamic_module_callback_http_get_request_headers_count(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_trailers_count is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers_count, but for the request trailers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers_count for more\n details."]
  pub fn envoy_dynamic_module_callback_http_get_request_trailers_count(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_headers_count is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers_count, but for the response headers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers_count for more\n details."]
  pub fn envoy_dynamic_module_callback_http_get_response_headers_count(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_trailers_count is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers_count, but for the response trailers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers_count for more\n details."]
  pub fn envoy_dynamic_module_callback_http_get_response_trailers_count(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
  ) -> usize;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_headers is called by the module to get all the\n request headers. The headers are returned as an array of envoy_dynamic_module_type_http_header.\n\n PRECONDITION: The module must ensure that the result_headers is valid and has enough length to\n store all the headers. The module can use\n envoy_dynamic_module_callback_http_get_request_headers_count to get the number of headers before\n calling this function.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param result_headers is the pointer to the array of envoy_dynamic_module_type_http_header where\n the headers will be stored. The lifetime of the buffer of key and value of each header is\n guaranteed until the end of the current event hook unless the setter callback are called.\n @return true if the operation is successful, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_get_request_headers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_headers: *mut envoy_dynamic_module_type_http_header,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_trailers is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers, but for the request trailers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers for more details."]
  pub fn envoy_dynamic_module_callback_http_get_request_trailers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_headers: *mut envoy_dynamic_module_type_http_header,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_headers is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers, but for the response headers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_headers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_headers: *mut envoy_dynamic_module_type_http_header,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_response_trailers is exactly the same as the\n envoy_dynamic_module_callback_http_get_request_headers, but for the response trailers.\n See the comments on envoy_dynamic_module_callback_http_get_request_headers for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_trailers(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_headers: *mut envoy_dynamic_module_type_http_header,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_request_header is called by the module to set\n the value of the request header with the given key. If the header does not exist, it will be\n created. If the header already exists, all existing values will be removed and the new value will\n be set.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param key is the key of the header.\n @param key_length is the length of the key.\n @param value is the value of the header.\n @param value_length is the length of the value.\n @return true if the operation is successful, false otherwise.\n\n Note that this only sets the header to the underlying Envoy object. Whether or not the header is\n actually sent to the upstream depends on the phase of the execution and subsequent\n filters. In other words, returning true from this function does not guarantee that the header\n will be sent to the upstream."]
  pub fn envoy_dynamic_module_callback_http_set_request_header(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value: envoy_dynamic_module_type_buffer_module_ptr,
    value_length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_request_trailer is exactly the same as the\n envoy_dynamic_module_callback_http_set_request_header, but for the request trailers.\n See the comments on envoy_dynamic_module_callback_http_set_request_header for more details."]
  pub fn envoy_dynamic_module_callback_http_set_request_trailer(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value: envoy_dynamic_module_type_buffer_module_ptr,
    value_length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_response_header is exactly the same as the\n envoy_dynamic_module_callback_http_set_request_header, but for the response headers.\n See the comments on envoy_dynamic_module_callback_http_set_request_header for more details."]
  pub fn envoy_dynamic_module_callback_http_set_response_header(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value: envoy_dynamic_module_type_buffer_module_ptr,
    value_length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_response_trailer is exactly the same as the\n envoy_dynamic_module_callback_http_set_request_header, but for the response trailers.\n See the comments on envoy_dynamic_module_callback_http_set_request_header for more details."]
  pub fn envoy_dynamic_module_callback_http_set_response_trailer(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    key: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value: envoy_dynamic_module_type_buffer_module_ptr,
    value_length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_send_response is called by the module to send the response\n to the downstream.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param status_code is the status code of the response.\n @param headers_vector is the array of envoy_dynamic_module_type_module_http_header that contains\n the headers of the response.\n @param headers_vector_size is the size of the headers_vector.\n @param body is the pointer to the buffer of the body of the response.\n @param body_length is the length of the body."]
  pub fn envoy_dynamic_module_callback_http_send_response(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    status_code: u32,
    headers_vector: *mut envoy_dynamic_module_type_module_http_header,
    headers_vector_size: usize,
    body: envoy_dynamic_module_type_buffer_module_ptr,
    body_length: usize,
  );
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_body_vector is called by the module to get the\n request body as a vector of buffers. The body is returned as an array of\n envoy_dynamic_module_type_envoy_buffer.\n\n PRECONDITION: The module must ensure that the result_buffer_vector is valid and has enough length\n to store all the buffers. The module can use\n envoy_dynamic_module_callback_http_get_request_body_vector_size to get the number of buffers\n before calling this function.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param result_buffer_vector is the pointer to the array of envoy_dynamic_module_type_envoy_buffer\n where the buffers of the body will be stored. The lifetime of the buffer is guaranteed until the\n end of the current event hook unless the setter callback is called.\n @return true if the body is available, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_get_request_body_vector(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_buffer_vector: *mut envoy_dynamic_module_type_envoy_buffer,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_request_body_vector_size is called by the module to get\n the number of buffers in the request body. Combined with\n envoy_dynamic_module_callback_http_get_request_body_vector, this can be used to iterate over all\n buffers in the request body.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param size is the pointer to the variable where the number of buffers will be stored.\n @return true if the body is available, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_get_request_body_vector_size(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    size: *mut usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_append_request_body is called by the module to append the\n given data to the end of the request body.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param data is the pointer to the buffer of the data to be appended.\n @param length is the length of the data.\n @return true if the body is available, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_append_request_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    data: envoy_dynamic_module_type_buffer_module_ptr,
    length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_drain_request_body is called by the module to drain the given\n number of bytes from the request body. If the number of bytes to drain is greater than\n the size of the body, the whole body will be drained.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param number_of_bytes is the number of bytes to drain.\n @return true if the body is available, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_drain_request_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    number_of_bytes: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " This is the same as envoy_dynamic_module_callback_http_get_request_body_vector, but for the\n response body. See the comments on envoy_dynamic_module_callback_http_get_request_body_vector\n for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_body_vector(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    result_buffer_vector: *mut envoy_dynamic_module_type_envoy_buffer,
  ) -> bool;
}
extern "C" {
  #[doc = " This is the same as envoy_dynamic_module_callback_http_get_request_body_vector_size, but for the\n response body. See the comments on\n envoy_dynamic_module_callback_http_get_request_body_vector_size for more details."]
  pub fn envoy_dynamic_module_callback_http_get_response_body_vector_size(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    size: *mut usize,
  ) -> bool;
}
extern "C" {
  #[doc = " This is the same as envoy_dynamic_module_callback_http_append_request_body, but for the response\n body. See the comments on envoy_dynamic_module_callback_http_append_request_body for more\n details."]
  pub fn envoy_dynamic_module_callback_http_append_response_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    data: envoy_dynamic_module_type_buffer_module_ptr,
    length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " This is the same as envoy_dynamic_module_callback_http_drain_request_body, but for the response\n body. See the comments on envoy_dynamic_module_callback_http_drain_request_body for more details."]
  pub fn envoy_dynamic_module_callback_http_drain_response_body(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    number_of_bytes: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_dynamic_metadata_number is called by the module to set\n the number value of the dynamic metadata with the given namespace and key. If the metadata is not\n accessible, this returns false. If the namespace does not exist, it will be created.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param namespace_ptr is the namespace of the dynamic metadata.\n @param namespace_length is the length of the namespace.\n @param key_ptr is the key of the dynamic metadata.\n @param key_length is the length of the key.\n @param value is the number value of the dynamic metadata to be set.\n @return true if the operation is successful, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_set_dynamic_metadata_number(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    namespace_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    namespace_length: usize,
    key_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value: f64,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_dynamic_metadata_number is called by the module to get\n the number value of the dynamic metadata with the given namespace and key. If the metadata is not\n accessible, the namespace does not exist, the key does not exist or the value is not a number,\n this returns false.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param namespace_ptr is the namespace of the dynamic metadata.\n @param namespace_length is the length of the namespace.\n @param key_ptr is the key of the dynamic metadata.\n @param key_length is the length of the key.\n @param result is the pointer to the variable where the number value of the dynamic metadata will\n be stored.\n @return true if the operation is successful, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_get_dynamic_metadata_number(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    namespace_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    namespace_length: usize,
    key_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result: *mut f64,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_set_dynamic_metadata_string is called by the module to set\n the string value of the dynamic metadata with the given namespace and key. If the metadata is not\n accessible, this returns false. If the namespace does not exist, it will be created.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param namespace_ptr is the namespace of the dynamic metadata.\n @param namespace_length is the length of the namespace.\n @param key_ptr is the key of the dynamic metadata.\n @param key_length is the length of the key.\n @param value_ptr is the string value of the dynamic metadata to be set.\n @param value_length is the length of the value.\n @return true if the operation is successful, false otherwise."]
  pub fn envoy_dynamic_module_callback_http_set_dynamic_metadata_string(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    namespace_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    namespace_length: usize,
    key_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    value_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    value_length: usize,
  ) -> bool;
}
extern "C" {
  #[doc = " envoy_dynamic_module_callback_http_get_dynamic_metadata_string is called by the module to get\n the string value of the dynamic metadata with the given namespace and key. If the metadata is not\n accessible, the namespace does not exist, the key does not exist or the value is not a string,\n this returns false.\n\n @param filter_envoy_ptr is the pointer to the DynamicModuleHttpFilter object of the\n corresponding HTTP filter.\n @param namespace_ptr is the namespace of the dynamic metadata.\n @param namespace_length is the length of the namespace.\n @param key_ptr is the key of the dynamic metadata.\n @param key_length is the length of the key.\n @param result_buffer_ptr is the pointer to the pointer variable where the pointer to the buffer\n of the value will be stored.\n @param result_buffer_length_ptr is the pointer to the variable where the length of the buffer\n will be stored.\n @return true if the operation is successful, false otherwise.\n\n Note that the buffer pointed by the pointer stored in result is owned by Envoy, and\n they are guaranteed to be valid until the end of the current event hook unless the setter\n callback is called."]
  pub fn envoy_dynamic_module_callback_http_get_dynamic_metadata_string(
    filter_envoy_ptr: envoy_dynamic_module_type_http_filter_envoy_ptr,
    namespace_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    namespace_length: usize,
    key_ptr: envoy_dynamic_module_type_buffer_module_ptr,
    key_length: usize,
    result: *mut envoy_dynamic_module_type_buffer_envoy_ptr,
    result_length: *mut usize,
  ) -> bool;
}
pub const kAbiVersion: &[u8; 65] =
  b"05d8d5fac54ffcfc596312d93fff5d5082cbe37d4aca21fd4270ffa253980f34\0";
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
